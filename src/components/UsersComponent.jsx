import React, { useState } from 'react';
import useSWR, { mutate } from 'swr';
import { fetchUsers, addUser, updateUser, deleteUser } from '../api';

const UsersComponent = () => {
  const [newUser, setNewUser] = useState({ name: '', email: '' });

  // Fetch users using SWR
  const { data: users, error } = useSWR('/api/users', fetchUsers);

  if (error) return <p>Error loading users: {error.message}</p>;
  if (!users) return <p>Loading users...</p>;

  // Add User
  const handleAddUser = async () => {
    const optimisticUser = { id: Math.random(), ...newUser }; // Temporary ID for optimistic update
    setNewUser({ name: '', email: '' });

    // Optimistically update the UI before the network request
    mutate('/api/users', [...users, optimisticUser], false);

    try {
      // Add the user to the server (mocked)
      const addedUser = await addUser(newUser);

      // Replace the optimistic user with the actual server response (if the real server responds)
      const updatedUsers = [...users, addedUser];
      mutate('/api/users', updatedUsers, false);  // Manually update cache without revalidating
    } catch (err) {
      console.error('Failed to add user:', err);

      // Roll back if the mutation fails
      mutate('/api/users', users, false);
    }
  };

  // Update User
  const handleUpdateUser = async (id) => {
    const updatedName = prompt('Enter new name:');
    if (!updatedName) return;

    const updatedUser = { id, name: updatedName };

    // Optimistically update the user in the UI
    const optimisticUsers = users.map((user) =>
      user.id === id ? { ...user, name: updatedName } : user
    );
    mutate('/api/users', optimisticUsers, false);

    try {
      // Send the updated user to the server (mocked)
      await updateUser(updatedUser);

      // Keep the updated data in the cache and avoid refetching old data from the server
      mutate('/api/users', optimisticUsers, false);  // Keep the updated data in cache
    } catch (err) {
      console.error('Failed to update user:', err);

      // Roll back if the mutation fails
      mutate('/api/users', users, false);
    }
  };

  // Delete User
// Delete User
const handleDeleteUser = async (id) => {
    // Optimistically remove the user from the UI
    const optimisticUsers = users.filter((user) => user.id !== id);
    mutate('/api/users', optimisticUsers, false); // Update the cache optimistically
  
    // Check if the user exists on the server (i.e., the ID is not a random temporary ID)
    if (id.toString().includes('.')) {  // Temporary ID generated by Math.random() contains '.'
      // No need to call the server for temporary IDs, just remove the user locally
      console.log('User added locally, removing from cache without server call.');
      return;
    }
  
    try {
      // Send delete request to the server (mocked)
      await deleteUser(id);
  
      // Manually update the SWR cache without refetching
      mutate('/api/users', optimisticUsers, false);
    } catch (err) {
      console.error('Failed to delete user:', err);
  
      // Roll back if the mutation fails
      mutate('/api/users', users, false);
    }
  };
  

  return (
    <div>
      <h2>Users List</h2>
      <input
        type="text"
        placeholder="Name"
        value={newUser.name}
        onChange={(e) => setNewUser({ ...newUser, name: e.target.value })}
      />
      <input
        type="email"
        placeholder="Email"
        value={newUser.email}
        onChange={(e) => setNewUser({ ...newUser, email: e.target.value })}
      />
      <button onClick={handleAddUser}>Add User</button>

      <ul>
        {users.map((user) => (
          <li key={user.id}>
            {user.name} ({user.email})
            <button onClick={() => handleUpdateUser(user.id)}>Edit</button>
            <button onClick={() => handleDeleteUser(user.id)}>Delete</button>
          </li>
        ))}
      </ul>
    </div>
  );
};

export default UsersComponent;
